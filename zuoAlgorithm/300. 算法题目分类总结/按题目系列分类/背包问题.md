# 背包系列问题


---

在动态规划中 只有试法是最重要的
你试法确定了, 动态规划也就直接确定了
因为从试法到动态规划, 是高度套路化的改进


背包系列问题分为两种类型:  
求背包中所装物品的最大价值 跟 装物品的方法数 


尽快都是[[从左往右的尝试模型]], 但是并不是说从左往右的尝试模型只能有包含, 不包含两种可能, 类似[[面值数组组成面值的最少货币数]], 从左往右到index位置的时候, 用0张, 1张, 2张....最大张数的时候停, 所有分支都走, 也是从左往右的尝试模型



##### 题目

[[背包能装下最多的价值]]   

[[背包中有多少种零食放法]]  == [[牛牛的背包问题]] 
>第一种试法:  从左往右的经典模型   
还剩的容量是rest，arr[index...]自由选择，返回选择方案   
之前的选择你别管, 已经选过了   
index ： 0～N  
rest : 0~w  
[[Basecase 返回特定值及设置无效解的技巧]]

>第二种试法:
>dp[i][j]: 0~i号零食自由选择, 但是我要求体积必须严格的累加成j的情况下, 方法数是多少?
最后一行   
0..N-1的零食严格体积为0的情况下, 方法数是a   
0..N-1的零食严格体积为1的情况下, 方法数是b   
0..N-1的零食严格体积为2的情况下, 方法数是c   
答案就是a+b+c...一直加到w, 全部加起来是最后结果   
[[第二维参数等于严格定义值的动态规划]]


[[普通硬币跟纪念币拼出指定面值]]   
>普通币: 没有重复值  
>纪念币: 可能有重复值  
>1.普通硬币问题: 无重复数组, 每个面值任意张, 找出每个钱数有多少种方法  
>dp[i][j]: 自由使用arr[0-i]号货币情况下, 搞定j元的方法数  

>2.纪念币问题: 普通背包问题    
>dp[i][j]: 自由使用arr 0..i所有货币, 每种货币最多使用一次, 能够拼出j元的方法数  
>经典背包,没有枚举行为  


[[非负数组子序列中累加和%m的最大值]]
>解法一: 背包  
>dp[i][sum]: arr 0...i范围上自由选择, 能否得到sum这个累加和
整个表示bool类型的表, 背包问题
最后一行, 0...N-1所有数任意选, 能否组成某个累加和

>解法二: 比较难设计  
>行: 所有数组的下标, 0..i
列: 0...m-1
dp[i][j]: arr 0...i所有数自由组合, 累加和在%m之后,能不能把j搞定
也是一个bool类型的表  
因为要求模之后数离m最大, 所以二维数组行设计为0..m-1, m-1是离m最大的
[[第二维参数等于严格定义值的动态规划]]