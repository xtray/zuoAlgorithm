# 范围上的尝试模型

#范围上尝试的模型 

---

一个样本做行一个样本做列的对应模型往往只讨论结尾如何如何, 但是范围上的尝试模型
讨论的是 开头和结尾共同结合的可能性如何如何



在一个字符串,或者一个样本上,选择各种不同的分割点, 这样的可能性展开, 最后对应到范围上尝试的模型  
因为有分割点的话,意味着, 左侧一个范围,右侧一个范围, 而且右侧的范围, 不是以最早0作为开头, 它是以一个[i..j]的位置作为开头的

所谓的[[样本对应模型]]还是范围上尝试的模型, 只是可能性组织方式
如果我发现我利用前缀串, 可能性的组织只讨论前缀串的结尾,类似这种的讨论, 不需要枚举分割点就能够把可能性讨论赶紧那就是[[样本对应模型]], 如果我发现我在一个范围上讨论, 必须找若干个分割点去求这个答案的话, 它就是范围上的尝试模型.

一个一个模型去套, 如果你发现可能性在组织的时候守不住, 那就换模型, 这个东西用起来只能是尝试过很多题目之后才有感觉
实在不行,就每个模型尝试一遍

比如基础课, 纸牌问题, 很明显不能通过只讨论结尾, 左右两侧都有可能缩, L,R是守不住的,
就放弃只讨论结尾, 既然开头守不住, 那我就定义成L..R上一个范围上的尝试模型
[[A,B玩家从左右两边拿纸牌,返回最后获胜者的分数]]


87.[[玄变字符串]]  Super Hard  
>str1: L1--R1, str2: L2..R2, 等长, 是否为旋变
一开始一个样本做行,一个样本做列  为什么猜不下去了?
是因为你开头0位置你守不住  
假设是一个样本做行,一个样本做列的对应模型, 我们把尝试定义为:  
str1 0...end 和 str2 0...end2 是否互为旋变串, 这个模型守不住, 为什么?    
当我枚举第一刀的时候, 子问题不再以0开头了  
所以我知道, 如果只有两个可变参数, 分别表示两个字符串的结尾,   
这个模型我守不住, 守不住的原因是:  
当我展开可能性的时候, 他的范围会变小,  而且这种范围变小不是它固定开头的情况下范围变小  
它连开头都换, 你就知道一个样本做行,一个样本做列模型你尝试不出来, 赶紧换别的  
在你实际执行的过程中, 你试不下去了, 所以得换个模型再试


[[奇怪的打印机]]

[[字符串express能有多少种组合方式，可以达到desired的结果]]

[[字符串变成回文的最少刀数]]

[[最少添加多少字符使字符串变为回文串]]
>str 从 L..R至少填几个变为回文, L..R是一个具体的范围, 不可能有L>R的时候, 所以这张表, 除了对角线, 左下半没有用  
>对角线代表: 
>0~0范围添几个字符是回文
>1~1范围添几个字符是回文
>2~2范围添几个字符是回文
>对角线全是0
>倒数第二条对角线怎么填写?
>0~1范围, 只有两个字符, 添几个字符是回文
>1~2范围, 只有两个字符, 添几个字符是回文
>2~3范围, 只有两个字符, 添几个字符是回文


[[子序列回文]]
>很难, 在于它可能性的梳理, 把范围上尝试的模型玩到了一种变态的地步了
>难点:  
想要的是邻近位置把 a +b +c +d精确的告诉我,  
而我们能够依赖的邻近位置是几种情况混在一起的  
我们想求a +b +c +d 这4种互斥情况的可能性  
问题在于邻近位置是几种可能性混在一起的答案  
想办法做加工


[[最长回文子序列]]  
>解法1: 字符串跟自己的逆序求[[最长公共子序列]]
>字符串和自己的逆序串的最长公共子序列 就是 原串的 最长回文子序列
>解法2: 范围尝试模型
>定义函数递归函数 f(str, L, R)  
string在 L...R的范围上最长回文子序列长度