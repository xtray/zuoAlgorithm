# 比较难想的动态规划设计


---


[[打怪兽需要花的最小钱数]]  
>dp[i][j]: 0号怪兽一路通关到i号怪兽, 严格花够j元能得到的最大能力
不能完成记-1

---

## [[货币兑换系列问题]]   

[[零钱兑换]]    
>dp[i][j]: 自由使用0...i上面所有的钱, 正好拼出j元的最少张数
>面值, 没有重复值


[[普通硬币跟纪念币拼出指定面值]]    
>普通币: 没有重复值
>纪念币: 可能有重复值
>1.无重复数组, 每个面值 任意张, 找出每个钱数有多少种方法  
>dp[i][j]: 自由使用arr[0-i]号货币情况下, 搞定j元的方法数
>2.纪念币问题: 普通背包问题  
>dp[i][j]: 自由使用arr 0..i所有货币, 每种货币最多使用一次, 能够拼出j元的方法数
>经典背包,没有枚举行为


[[货币数组组成面值的方法数-同值认为不同]]     
>从arr index出发及其后面所有货币自由选择, 组成正好rest这么多的钱有几种方法   

[[面值数组组成面值的方法数-张数不限]]   
>从arr index出发及其后面所有的面值, 每一个面值都可以自由选择, 组成正好rest这么多的钱, 方法数是多少?   

[[货币数组组成面值的方法数-同值无差别(张数限定)]]   
>从arr index出发及其往后所有的面值在张数规定好的情况下组成rest的方法数     

[[货币数组组成面值的最少货币数]]   
>从arr index出发及其往后所有的货币可以自由使用怎么搞定rest元, 最小张数是多少   



---

[[非负数组子序列中累加和%m的最大值]]
>解法一: 背包  
>dp[i][sum]: arr 0...i范围上自由选择, 能否得到sum这个累加和
整个表示bool类型的表, 背包问题
最后一行, 0...N-1所有数任意选, 能否组成某个累加和
>解法二: 比较难设计  
>行: 所有数组的下标, 0..i
列: 0...m-1
dp[i][j]: arr 0...i所有数自由组合, 累加和在%m之后,能不能把j搞定
也是一个bool类型的表  
因为要求模之后数离m最大, 所以二维数组行设计为0..m-1, m-1是离m最大的


---

**在整个暴力递归到动态规划中地位非常高, 因为这个递归不需要搞成严格表结构的动态规划
**

[[多少张贴纸可以贴出给定字符串|贴纸拼词]]
> 尝试:   
1.第一张贴纸用谁     
先排序(为了命中率高一些, 不排序也可以)   
第一张贴纸选 abc   
第一张贴纸选 bba   
第一张贴纸选 cck   
..
尝试所有可能的第一张, 答案必在其中   
2.高效一点的尝试方法  
很重要的优化:  
词频表直接互怼, 会快很多 而且所有贴纸的词频都是提前生成好的   
第二个重要优化就是剪枝  少走了很多冤枉路  