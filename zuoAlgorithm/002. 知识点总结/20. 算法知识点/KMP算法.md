# KMP算法

#KMP算法 

---

题目: [[字符串str中是否有某个子串是等于字符串match]]

next数组, i位置的信息:  i位置之前的字符串, 不能取到整体的情况下, 前缀跟后缀的最长匹配长度
0位置的信息: 0位置没有之前的字符串, 概念不存在, 人为规定-1 
1位置的信息: 1位置之前字符串长度1, 不能取整体, 字符串长度0, 人为规定为0

## KMP算法核心

1）如何理解next数组  
2）如何利用next数组加速匹配过程，优化时的两个实质！（私货解释）  

- [[KMP算法代码]]

### KMP算法的复杂度估计

```java
// O(N)
while (x < str.length && y < match.length) {
    if (str[x] == match[y]) { // ①
        x++;
        y++;
    } else if (next[y] == -1) { // y == 0　②
        x++;
    } else {// ③
        y = next[y];
    }
}

```


代码中设计两个变量x, y,   x的变化趋势一直在上升(从0~N-1) , 而y有的时候在上升,有的时候在下降:
在分支①中, y变化趋势在增加, 而在分支③中, y回退下降
所以只靠x, y没有办法估计复杂度, 需要做数学上的转化, 
数学上如果两个量, 一个上升, 一个下降, 怎么评估整体的变化, 常见的方法是:  
对这两个量做差, 或者做除, 就是想办法找到两个跟x,y有关的新的量, 让他不回退,此处的算法复杂度估计就是这个办法. 设计的新变量x-y 没有具体的含义.


>现在我说我，我们我们打算干一件事儿，干这个事儿的时候会让一个量推高，但是另外一个量有可能推高，有可能减小，你怎么评估这个这个工作要做多久才能做完？那你要是眼光就锁在这两个量上，你就没就没戏了，另外一个量有时候会变小，你不知道怎么弄了，所以说看啥看，既然都增长这个量，跟有的时候减少这个量，咱做个减号，咱做个差，这样就评估出来整体的一种变化趋势了吗？有的时候做除理解吧，做差或做除就数量常见的一种分析技巧，他不一定非得赋予它的含义啊。


因为三个代码分支只会进入一个,  所以我们构造两个量来辅助复杂度计算:
 x: str中的位置
 y: match中的位置, x-y, x最大N, y最小0
 
 因为x和y并不都回退。所以常规的估计没法做。于是构造两个量，一个是X，一个是X-Y，用这两个不回退的量来估计时间复杂度。你可以认为没啥实际含义，就是找到了这么两个量，可以用来评估复杂度。
 
 