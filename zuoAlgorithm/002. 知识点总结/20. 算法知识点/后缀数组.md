# 后缀数组

#后缀数组

---

## 后缀数组的代码模板
让你做黑盒的东西, DC3算法实现两种实现:    
1)  打wordFinal的国手留下的模板   
2) 后缀数组DC3算法，论文里的代码改成了java的。   
    现在这个算法不再是acm world final选手的版本了，
    是逐行翻译的论文里的C语言代码，改成了java的。
    这样更好一些。具体解释可以去看课，代码就是课上讲的过程。没那么难看懂了。


## DC3算法生成后缀数组
http://algo2.iti.kit.edu/documents/jacm05-revised.pdf   
http://spencer-carroll.com/the-dc3-algorithm-made-simple/   

>DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 "Simple Linear Work Suffix Array Construction" 中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于[[bfprt算法]]找中位数的median of medians，它采用分治思想: 先用递归方式对起始下标等于1(mod 3)和2(mod 3)的后缀排序，从而将原始的后缀集合大小缩小为2/3，设这些后缀排好序的结果为S12，然后在S12的基础上对起始下标等于0(mod 3)的后缀排序（这一步只需作两位数的基数排序，一位为0(mod 3)的起始下标，另外一位为S12的rank值），设这一步得到的排好序的后缀数组为S0，最后将S0和S12归并（类似于归并排序算法）。归并过程通过Difference Cover思想，也是在S12已知的基础上分两个cases得出相邻两个后缀的先后顺序。

![[DC3_Algorithm.pdf]]

---

## 后缀数组是什么?
如果我要排序的话, 按字符串的字典序来排  
这个就是后缀数组  
  
以某个位置开始后面整体的后缀串, 它在所有开头位置的后缀串中排名第几, 把它自己的排名作为一个数组返回  
跟它对应的就是rank数组  
  
后缀数组跟rank数组就是一种转换关系, 后缀数组可以在O(N)的时间内转化为rank数组  
rank数组可以在O(N)的时间内转化为后缀数组

后缀数组+rank数组 可以接解决非常多的字符串问题  
还能去做[[RMQ问题]]
关键点在于后缀数组怎么样形成最方便

## 后缀数组的地位
它的地位非常高, 很多的问题都是由[[后缀树]] 或 后缀数组实现的  

[[后缀树]]  实现 跟后缀数组实现的区别:    
后缀数组可以替代非常多后缀树的内容  
因为后缀树生成是更麻烦的一个东西  
我用后缀数组可以代表字符串的一些后缀信息, 可以解决很多  
字符串的问题

## 为什么要讲后缀数组?  
首先很多字符串问题是以后缀数组作为最优解  
意味着有很多问题,在你在面试的过程中聊出来的话, 极大的涨身价的  
有点装逼性质的, 但实际上它非常有用, 只是因为过于难导致  
反而在要求上不会要求到这种程度


## 笔试/面试中后缀数组的地位
在笔试/面试中, 会设置一个问题跟他认为的后台的最优解  
他在设计问题的时候都会选择一定的数据范围, 他的最优解是卡这个  
数据范围然你过的  
1) 有些问题, 它可能会有一个一般解, 或者说暴力解, 他不让你通过  
2) 它可能会有一个优化解, 通过的test case的比例大概70%, 剩下的  
 就过不了了, 因为你没优化够  
3) 如果你能做出他所规定的的最优解的指标的话, 他会让你通过100%  
 就是我们所谓的AC  
  
  
如果一个问题是后缀数组解的, 它的最优解是后缀数组  
这样的问题在笔试中出现, 是第4种方法:  
4) 后缀数组的解  
 3)中这个最优解是官方给你的最优解, 官方给你的一个指标,   
 到这里就能通过  
 后缀数组的解往往比官方给的最优解还要好  
 而且官方因为它太难, 都不会把后缀数组的解设为官方的答案  
这就是它的地位



## 后缀数组的应用
网上搜帖子看就行
https://www.cnblogs.com/yongren1zu/p/3239428.html


## 题目
[[后缀数组DC3算法实现]]     
[[拼接最大数]]     
[[最大数]]     
[[插入字符串所形成的数值最大值]]     



