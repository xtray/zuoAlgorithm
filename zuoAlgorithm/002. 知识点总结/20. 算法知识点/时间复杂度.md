# 时间复杂度


---
## 什么是时间复杂度？时间复杂度怎么估算？
常数时间的操作
确定算法流程的总操作数量与样本数量之间的表达式关系
只看表达式最高阶项的部分


## 何为常数时间的操作？
如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。


## 常见的常数时间的操作
- 常见的算术运算（+、-、*、/、% 等）
- 常见的位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

总之，执行时间固定的操作都是常数时间的操作。
反之，执行时间不固定的操作，都不是常数时间的操作。


## 如何确定算法流程的时间复杂度？
当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。  
记为：O(忽略掉系数的高阶项)

---

当数据量很大, 系数项跟低阶项根本不重要, 决定算法运行时间的就是最高阶项 时间复杂度是一个非常好用的指标: 它的好用在于我的数据量很大的情况下, 我怎么去描述这样一个算法时间的关系

当我知道时间复杂度它会忽略系数跟低阶项, 有了这个设定之后, 我们在分析一个算法流程的时候, 不一定很麻烦, 定性的来, 只要找到一种等差感, 它肯定是N^2的

一般来讲底数是被省略了, $O(logN)$默认就是以2为底的   
如果不是以2为底就单独写一下比如 $O(log_3N)$   
有的时候连3都省略了, 有时候$O(log_7N)$也写成$O(logN)$   
因为你底数不管是多少, 它出来的值都很小   
long类型, 最大2^64, 这么大的数, 二分的话, 64次就处理完了   
所以往往就忽略这个底,    
如果这个底等于2或者比2大, 它出来的结果都会很小, 所以默认就写成 $O(logN)$了    

常数操作 跟数据量无关, 认为规定复杂度是 O(1)   

做时间复杂度估计的时候, 一定要用最差情况   


[[01 认识复杂度、对数器、二分法与异或运算]]

[[关于常数项需要注意的]]

[[Java中ArrayList 扩容的代价]]