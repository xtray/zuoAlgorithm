# Java中的整型, 正数, 负数


---

Java 中提供了一个byte数据类型，并且是基本类型。
在Java中，byte类型的数据是8位带符号的二进制数。
Java byte是做为最小的数字来处理的，因此它的值域被定义为-128~127，也就是signed byte
https://www.cnblogs.com/zl181015/p/9435035.html
```java
byte a = 127; 
a+=1; 
System.out.println(a);

int b = 456;
byte test = (byte) b; // 当int转成byte的时候，那么计算机会只保留最后8位
System.out.println(test); // 最后会输出-56

```


Java 中整型是32位, long是64位


2147483647

整型最大值留着最高位1没有占用

一个整型系统中32位没有都用, 真正表示值的范围是从0~30共31位, 能表示的最大整数2^31-1

留着最高位是为了即表示整数, 又表示负数


无符号整数, C++里有
0~2^32-1 共有 2^32个数

在Java中, 是一个有符号数, 几乎一半给负的, 一半给正的
- 2^31 ~ 2^32-1  共有 2^32个数


### 正数怎么表达?
如果符号位是0, 肯定不是负数, 非负数
### 负数怎么表达?
负数在计算机里使用补码表示, 即对应正数的取反+1
由补码得到对应的数: 
符号位是1, 值是后面的状态取反+1

比如: -1 的表示
1 1111111111111111111111111111111

符号1: 代表是负数,
后面取反, 变为0, 再加1, ==> -1



系统最小呢?
1 000000000000000000000000
符号1: 代表是负数,
后面取反, 变为1, 再加1, 后面都变0, 有一个进位是 2^31==> - 2^31


### 取反操作

符号~
```java

int b = 13213;
int c = ~b;
```


- 为什么负值的极值是 1 000000000000000000000000 ?

负的最小: -2147483648
正的最大: 2147483647

-2^31 ~ 2^31 - 1

整数的表达,
最高位0, 剩下的31位表示数值, 所以整数 2^31-1, 非负因为有0, 所以少了1个

负数最小:
1 000000000000000000000000
忽略1 取反后 都是1, 再+1, 到了 2^31, 没有0的负担

系统最小的绝对值, 比 系统最大的绝对值 多1


### 负数为什么要取反+1

加减乘除在系统底层内部都是二进制位运算来实现的

a + b ==> 用位运算逻辑拼
如果 a是负数, 不想专门定制
只想加减乘除在系统底层内部实现是一套, 为了在实际执行的时候能够快一些
越底层应该越高效

### 怎么求一个数的相反数?

int c = 5;
int d = -c;

还能怎么写?
d = (~c + 1)

### 最小的负数的相反数?
正数的相反数都有负数对应   
==最小的负数没有正数对应, 取反+1 还是它自己==

如果真的需要, 用long类型!

负数取反, 符号位算不算都无关, 因为符号位1会变为0, 不影响

### 0 的相反数是谁?
溢出了, 不要, 还是它自己


### 负数右移
System.out.println(-3>>1);结果是-2,为什么会是-2呢?

下面我们来看一下.System.out.println(Integer.toHexString(-3));
得到-3的16进制为fffffffd(此为-3的补码,计算机中负数用补码表示).
转换成2进制为
1111 1111 1111 1111 1111 1111 1111 1101

右移一位为
1111 1111 1111 1111 1111 1111 1111 1110
显而易见此为-2补码.

左移
System.out.println(-3<<1);
左移相对来说比较简单.
1111 1111 1111 1111 1111 1111 1111 1101
左移一位为
1111 1111 1111 1111 1111 1111 1111 1010,
其为-6的补码.

无符号右移
System.out.println(-3>>>1);
1111 1111 1111 1111 1111 1111 1111 1101
无符号右移,高位补0,
01111 1111 1111 1111 1111 1111 1111 1110,
其为2147483646的原码.


